\section{Introduction}\label{intro}
Implementing an automated poker player is challenging since poker involves
elements of uncertainty, randomness, strategic interaction, and game-theoretic
reasoning. Heads-up poker is a form of Texas Hold'em poker that is played 
between two players. In this project, we aim to discuss implementing an 
automated heads-up poker player. Our approach to this problem is breaking
the problem into a sequence of simplified problems. 

The rest of this progress report is organize as follows: in \S 2 we describe the
rules of heads-up poker and the dynamics of the game. In \S 3 we will
demonstrate the hierarchy of simplified problems and their complexity.
\S 4 contains our main model for the project and \S 5 describes our implementation
so far. Finally, a discussion on our roadmap and future work is brought in \S6.

\section{Rules}
We are going to build our model based on \emph{Doyle's game} which was used 
in the 2007 Association for the Advancement of Artificial Intelligence (AAAI) 
Computer Poker Competition. The game is played between two players that we 
will call player A and player B. 

\BIT
\item \textbf{Blinds:} Every hand, both players start with 1000 chips. In odd hands (every other 
hand), player A is the \emph{small blind} and contributes 1 chip to the pot, while 
player B is the \emph{big blind} and contributes 2 chip to the pot. In even hands the 
role of two players is reversed. 
\item \textbf{Pre-flop:} Two players are dealt random cards (face down) which are called
\emph{hole cards}. Then the small blind can either \emph{fold} (\ie yield all the chips in
the pot to the other player), \emph{call} (contribute chips to the pot such that the number
of contributed chips from two players are equal), or \emph{raise} (contributing more chips
to the pot than the opponent). Notice that the famous \emph{all-in} action is a especial case
of raising. The betting process goes on until one player stops raising (and folds or simply calls).
\item \textbf{Flop:} Three community cards from the rest of the deck are shown. Starting from
the big blind, the betting process starts over similar to pre-flop. Unlike pre-flop where the
players are only using their hole cards to make actions, here the players are getting more
information about the community cards.
\item \textbf{Turn:} A fourth community card dealt face up. The betting process is similar to
flop.
\item \textbf{River:} A fifth (and last) community card is shown. A final round of bets takes place
similar to flop and turn.
\item \textbf{Show down:} In the event that none of the players fold until the end of river round,
two players make the best combination of five cards out of seven cards (two hole cards and 
five community cards). The player with a better combination wins the pot. In the case of
two equally ranked hands, the pot is split.
\EIT

\section{Implementation}
We use Python for our implementation. We have a class {\tt pokerCards} that consists
two subclasses {\tt card} and {\tt deck}. Each {\tt card} has two parameters rank and suit.
Rank is a number in $\{2,3,\cdots,14\}$ (where 14 means Ace) and suit is a number in 
$\{1,2,3,4\}$. The {\tt deck} has methods like pop and shuffle.

We also have another class {\tt handEvaluator} that contains functions to evaluate poker hands.
In particular, the method we use is inspired by [1]. The idea here is to assign scores to sets of
five, six, or seven cards such that the hand with higher rank has a higher score and equally-ranked
hands have the exact score. Specifically, {\tt handEvaluator} function receives the hole cards and  
the board (with three to five cards) as its arguments and assigns a real number in $[0,1]$
to the union of hole cards and the board. If {\tt handEvaluator(h1,b) > handEvaluator(h2,b)},
it means that the rank of best five cards in {\tt h1$\cup$b} is higher than the best five cards
in {\tt h2$\cup$b}. Notice that this doesn't mean the {\tt h1} does not have any chance to win.
